name: Refresh Telegram Video

on:
  schedule:
    - cron: '*/6 * * * *'   # every 5 minutes (min interval is 5 min). Change if needed. 
  workflow_dispatch:

# <-- grant write permission for commits/pushes
permissions:
  contents: write


jobs:
  refresh:
    runs-on: ubuntu-latest
    concurrency:
      group: refresh-telegram-video-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - name: Install tools
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Get state from gist (or create gist)
        env:
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          GIST_ID: ${{ secrets.GIST_ID || '' }}
          STATE_FILE: state.json
        run: |
          set -euo pipefail
          AUTH_HEADER="Authorization: token ${GIST_TOKEN}"
          if [ -n "${GIST_ID}" ]; then
            echo "Fetching existing gist ${GIST_ID}..."
            GIST_JSON=$(curl -s -H "$AUTH_HEADER" "https://api.github.com/gists/${GIST_ID}")
            if echo "$GIST_JSON" | jq -e '.message' >/dev/null 2>&1; then
              echo "Failed to fetch gist id=${GIST_ID}:" >&2
              echo "$GIST_JSON" | jq .
              exit 1
            fi
            echo "$GIST_JSON" | jq -r '.files["state.json"].content // "{}"' > "$STATE_FILE"
          else
            echo "No GIST_ID provided: creating a new private gist..."
            PAYLOAD=$(jq -n '{ "description":"telegram-state-for-refresh-video", "public": false, "files": { "state.json": {"content": "{}"} } }')
            CREATE=$(curl -s -H "$AUTH_HEADER" -H "Content-Type: application/json" -d "$PAYLOAD" https://api.github.com/gists)
            GIST_ID_OUT=$(echo "$CREATE" | jq -r '.id // empty')
            if [ -z "$GIST_ID_OUT" ]; then
              echo "Failed to create gist:" >&2
              echo "$CREATE" | jq .
              exit 1
            fi
            echo "Created gist id: $GIST_ID_OUT"
            echo "$CREATE" | jq -r '.files["state.json"].content // "{}"' > "$STATE_FILE"
            echo "Save this id as the repo secret GIST_ID for future runs: $GIST_ID_OUT"
          fi

      - name: Refresh Telegram video (use gist-state)
        env:
          BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          STATE_FILE: state.json
          VIDEO_PATH: :3.mp4
          EXTERNAL_VIDEO_URL: ""
        run: |
          # --- robust send / parse (paste into your step) ---
          # NOTE: assumes VIDEO_PATH is set and state.json already read earlier
          set -euo pipefail
          API="https://api.telegram.org/bot${BOT_TOKEN}"
          
          # sanity check video file when uploading a local file
          if [ -z "${FILE_ID}" ]; then
            if [ ! -f "${VIDEO_PATH}" ]; then
              echo "ERROR: video file not found at: ${VIDEO_PATH}" >&2
              ls -la || true
              exit 1
            fi
          fi
          
          # perform send with HTTP code attached to output
          if [ -n "${FILE_ID}" ]; then
            SEND_RAW=$(curl -s -w "\n__HTTP_CODE__:%{http_code}" -X POST "${API}/sendVideo" \
              -d chat_id="${CHAT_ID}" -d video="${FILE_ID}" -d disable_notification=true) || true
          else
            SEND_RAW=$(curl -s -w "\n__HTTP_CODE__:%{http_code}" -X POST "${API}/sendVideo" \
              -F chat_id="${CHAT_ID}" -F "video=@${VIDEO_PATH}" -F disable_notification=true) || true
          fi
          
          # split
          HTTP_CODE=$(printf '%s' "$SEND_RAW" | tail -n1 | sed -E 's/__HTTP_CODE__:(.*)/\1/')
          SEND_JSON=$(printf '%s' "$SEND_RAW" | sed '$d' || true)
          
          echo "sendVideo returned HTTP code: $HTTP_CODE"
          echo "First 1000 chars of response (raw):"
          printf '%s' "$SEND_JSON" | head -c 1000 || true
          # save raw output for later analysis
          printf '%s\n\n__HTTP_CODE__:%s\n' "$SEND_JSON" "$HTTP_CODE" > send.raw.txt
          
          # make sure it is JSON before parsing with jq
          if ! printf '%s' "$SEND_JSON" | jq -e . >/dev/null 2>&1; then
            echo "ERROR: Telegram response is not valid JSON. Saved raw to send.raw.txt" >&2
            echo "Contents (raw saved):"
            sed -n '1,200p' send.raw.txt || true
            exit 1
          fi
          
          ok=$(printf '%s' "$SEND_JSON" | jq -r '.ok // false')
          if [ "$ok" != "true" ]; then
            echo "Telegram API returned ok=false. Full response:"
            printf '%s\n' "$SEND_JSON" | jq .
            exit 1
          fi
          
          NEW_MSG_ID=$(printf '%s' "$SEND_JSON" | jq -r '.result.message_id')
          NEW_FILE_ID=$(printf '%s' "$SEND_JSON" | jq -r '.result.video.file_id // .result.document.file_id // empty')
          jq -n --arg m "$NEW_MSG_ID" --arg f "$NEW_FILE_ID" '{message_id:$m|tonumber, file_id:$f}' > "$STATE_FILE"
          echo "Sent ok â€” new message $NEW_MSG_ID, recorded state.json"
          # --- end robust send / parse ---

      - name: Save updated state back to gist
        env:
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          GIST_ID: ${{ secrets.GIST_ID }}
          STATE_FILE: state.json
        run: |
          set -euo pipefail
          if [ -z "${GIST_ID+x}" ] || [ -z "$GIST_ID" ]; then
            echo "GIST_ID unset. Save the created gist id to repo secrets as GIST_ID for future runs." && exit 0
          fi
          CONTENT=$(jq -Rs '.' < "$STATE_FILE")
          PAYLOAD=$(jq -n --arg c "$CONTENT" '{ files: { "state.json": { "content": ($c|fromjson) } } }')
          RESPONSE=$(curl -s -X PATCH -H "Authorization: token ${GIST_TOKEN}" -H "Content-Type: application/json" -d "$PAYLOAD" "https://api.github.com/gists/${GIST_ID}")
          echo "Gist update response:"
          echo "$RESPONSE" | jq . || true
