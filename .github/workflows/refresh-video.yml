name: Refresh Telegram Video

on:
  schedule:
    - cron: '*/6 * * * *'   # every 5 minutes (min interval is 5 min). Change if needed. 
  workflow_dispatch:

# <-- grant write permission for commits/pushes
permissions:
  contents: write


jobs:
  refresh:
    runs-on: ubuntu-latest
    concurrency:
      group: refresh-telegram-video-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - name: Install tools
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Get state from gist (or create gist)
        env:
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          GIST_ID: ${{ secrets.GIST_ID || '' }}
          STATE_FILE: state.json
        run: |
          set -euo pipefail
          AUTH_HEADER="Authorization: token ${GIST_TOKEN}"
          if [ -n "${GIST_ID}" ]; then
            echo "Fetching existing gist ${GIST_ID}..."
            GIST_JSON=$(curl -s -H "$AUTH_HEADER" "https://api.github.com/gists/${GIST_ID}")
            if echo "$GIST_JSON" | jq -e '.message' >/dev/null 2>&1; then
              echo "Failed to fetch gist id=${GIST_ID}:" >&2
              echo "$GIST_JSON" | jq .
              exit 1
            fi
            echo "$GIST_JSON" | jq -r '.files["state.json"].content // "{}"' > "$STATE_FILE"
          else
            echo "No GIST_ID provided: creating a new private gist..."
            PAYLOAD=$(jq -n '{ "description":"telegram-state-for-refresh-video", "public": false, "files": { "state.json": {"content": "{}"} } }')
            CREATE=$(curl -s -H "$AUTH_HEADER" -H "Content-Type: application/json" -d "$PAYLOAD" https://api.github.com/gists)
            GIST_ID_OUT=$(echo "$CREATE" | jq -r '.id // empty')
            if [ -z "$GIST_ID_OUT" ]; then
              echo "Failed to create gist:" >&2
              echo "$CREATE" | jq .
              exit 1
            fi
            echo "Created gist id: $GIST_ID_OUT"
            echo "$CREATE" | jq -r '.files["state.json"].content // "{}"' > "$STATE_FILE"
            echo "Save this id as the repo secret GIST_ID for future runs: $GIST_ID_OUT"
          fi

      - name: Refresh Telegram video (use gist-state)
        env:
          BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          STATE_FILE: state.json
          VIDEO_PATH: :3.mp4
          EXTERNAL_VIDEO_URL: ""
        run: |
          # --- safe state read + robust send ---
          set -euo pipefail
          
          STATE_FILE="state.json"
          API="https://api.telegram.org/bot${BOT_TOKEN}"
          
          # Read previous state (safe)
          MESSAGE_ID=""
          FILE_ID=""
          if [ -f "$STATE_FILE" ]; then
            MESSAGE_ID=$(jq -r '.message_id // empty' "$STATE_FILE" 2>/dev/null || echo "")
            FILE_ID=$(jq -r '.file_id // empty' "$STATE_FILE" 2>/dev/null || echo "")
          fi
          
          # Ensure variables are defined (avoid unbound var with set -u)
          : "${FILE_ID:=}"
          # default local file name (change if your file has a different name)
          : "${VIDEO_PATH:=video.mp4}"
          : "${EXTERNAL_VIDEO_URL:=${EXTERNAL_VIDEO_URL:-}}"
          
          echo "MESSAGE_ID='${MESSAGE_ID:-<empty>}'"
          echo "FILE_ID='${FILE_ID:0:8}... (redacted if present)'"
          echo "VIDEO_PATH='$VIDEO_PATH'"
          echo "EXTERNAL_VIDEO_URL='${EXTERNAL_VIDEO_URL:+<set>}'"
          
          # If VIDEO_PATH looks wrong (like starting with a colon), fail early with a hint
          if [[ "$VIDEO_PATH" == :* ]]; then
            echo "ERROR: VIDEO_PATH seems invalid ('$VIDEO_PATH'). Remove leading ':' or set EXTERNAL_VIDEO_URL." >&2
            ls -la || true
            exit 1
          fi
          
          # delete previous message (best-effort)
          if [ -n "$MESSAGE_ID" ]; then
            echo "Attempting to delete previous message $MESSAGE_ID..."
            curl -s -X POST "${API}/deleteMessage" -d chat_id="${CHAT_ID}" -d message_id="${MESSAGE_ID}" || true
          fi
          
          # If no file_id and EXTERNAL_VIDEO_URL provided, download it
          if [ -z "$FILE_ID" ] && [ -n "$EXTERNAL_VIDEO_URL" ]; then
            echo "Downloading external video from $EXTERNAL_VIDEO_URL..."
            curl -sSfL "$EXTERNAL_VIDEO_URL" -o /tmp/video.mp4
            VIDEO_PATH="/tmp/video.mp4"
          fi
          
          # Ensure upload file exists (if we need to upload)
          if [ -z "$FILE_ID" ]; then
            if [ ! -f "$VIDEO_PATH" ]; then
              echo "ERROR: video file not found at $VIDEO_PATH" >&2
              echo "Working dir listing:"
              ls -la || true
              exit 1
            fi
          fi
          
          # send with HTTP code, save raw output for debugging
          if [ -n "$FILE_ID" ]; then
            SEND_RAW=$(curl -s -w "\n__HTTP_CODE__:%{http_code}" -X POST "${API}/sendVideo" \
              -d chat_id="${CHAT_ID}" -d video="${FILE_ID}" -d disable_notification=true) || true
          else
            SEND_RAW=$(curl -s -w "\n__HTTP_CODE__:%{http_code}" -X POST "${API}/sendVideo" \
              -F chat_id="${CHAT_ID}" -F "video=@${VIDEO_PATH}" -F disable_notification=true) || true
          fi
          
          HTTP_CODE=$(printf '%s' "$SEND_RAW" | tail -n1 | sed -E 's/__HTTP_CODE__:(.*)/\1/')
          SEND_JSON=$(printf '%s' "$SEND_RAW" | sed '$d' || true)
          
          # save raw for inspection
          printf '%s\n\n__HTTP_CODE__:%s\n' "$SEND_JSON" "$HTTP_CODE" > send.raw.txt
          
          echo "sendVideo HTTP code: $HTTP_CODE"
          printf 'sendVideo response (first 1000 chars):\n'; printf '%s' "$SEND_JSON" | head -c 1000 || true
          
          # make sure response is JSON before using jq
          if ! printf '%s' "$SEND_JSON" | jq -e . >/dev/null 2>&1; then
            echo "ERROR: Telegram response not JSON. Inspect send.raw.txt in logs/artifacts." >&2
            exit 1
          fi
          
          ok=$(printf '%s' "$SEND_JSON" | jq -r '.ok // false')
          if [ "$ok" != "true" ]; then
            echo "Telegram API error (ok=false):"
            printf '%s\n' "$SEND_JSON" | jq .
            exit 1
          fi
          
          NEW_MSG_ID=$(printf '%s' "$SEND_JSON" | jq -r '.result.message_id')
          NEW_FILE_ID=$(printf '%s' "$SEND_JSON" | jq -r '.result.video.file_id // .result.document.file_id // empty')
          
          jq -n --arg m "$NEW_MSG_ID" --arg f "$NEW_FILE_ID" '{message_id:$m|tonumber, file_id:$f}' > "$STATE_FILE"
          echo "Success: posted message $NEW_MSG_ID; updated $STATE_FILE"
          # --- end safe block ---

      - name: Save updated state back to gist
        env:
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          GIST_ID: ${{ secrets.GIST_ID }}
          STATE_FILE: state.json
        run: |
          set -euo pipefail
          if [ -z "${GIST_ID+x}" ] || [ -z "$GIST_ID" ]; then
            echo "GIST_ID unset. Save the created gist id to repo secrets as GIST_ID for future runs." && exit 0
          fi
          CONTENT=$(jq -Rs '.' < "$STATE_FILE")
          PAYLOAD=$(jq -n --arg c "$CONTENT" '{ files: { "state.json": { "content": ($c|fromjson) } } }')
          RESPONSE=$(curl -s -X PATCH -H "Authorization: token ${GIST_TOKEN}" -H "Content-Type: application/json" -d "$PAYLOAD" "https://api.github.com/gists/${GIST_ID}")
          echo "Gist update response:"
          echo "$RESPONSE" | jq . || true
