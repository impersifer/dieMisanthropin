name: Refresh Telegram Video

on:
  schedule:
    - cron: '*/6 * * * *'   # every 6 minutes (adjust if needed)
  workflow_dispatch:

permissions:
  contents: write

jobs:
  refresh:
    runs-on: ubuntu-latest
    concurrency:
      group: refresh-telegram-video-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: sudo apt-get update && sudo apt-get install -y jq curl

      - name: Get state from gist (or create gist)
        env:
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
          GIST_ID: ${{ secrets.GIST_ID || '' }}
          STATE_FILE: state.json
        run: |
          set -euo pipefail
          AUTH_HEADER="Authorization: token ${GIST_TOKEN}"
          if [ -n "${GIST_ID}" ]; then
            echo "Fetching existing gist ${GIST_ID}..."
            GIST_JSON=$(curl -s -H "$AUTH_HEADER" "https://api.github.com/gists/${GIST_ID}")
            if echo "$GIST_JSON" | jq -e '.message' >/dev/null 2>&1; then
              echo "Failed to fetch gist id=${GIST_ID}:" >&2
              echo "$GIST_JSON" | jq .
              exit 1
            fi
            echo "$GIST_JSON" | jq -r '.files["state.json"].content // "{}"' > "$STATE_FILE"
          else
            echo "No GIST_ID provided: creating a new private gist..."
            PAYLOAD=$(jq -n '{ "description":"telegram-state-for-refresh-video", "public": false, "files": { "state.json": {"content": "{}"} } }')
            CREATE=$(curl -s -H "$AUTH_HEADER" -H "Content-Type: application/json" -d "$PAYLOAD" https://api.github.com/gists)
            GIST_ID_OUT=$(echo "$CREATE" | jq -r '.id // empty')
            if [ -z "$GIST_ID_OUT" ]; then
              echo "Failed to create gist:" >&2
              echo "$CREATE" | jq .
              exit 1
            fi
            echo "Created gist id: $GIST_ID_OUT"
            echo "$CREATE" | jq -r '.files["state.json"].content // "{}"' > "$STATE_FILE"
            echo "Save this id as the repo secret GIST_ID for future runs: $GIST_ID_OUT"
          fi

      - name: Refresh Telegram video (use gist-state)
        env:
          BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          STATE_FILE: state.json
          # keep the filename exactly as you asked (leading colon)
          VIDEO_PATH: ":3.mp4"
          EXTERNAL_VIDEO_URL: ""
        run: |
          # --- safe state read + robust send (accepts filenames that start with ':') ---
          set -euo pipefail

          STATE_FILE="state.json"
          API="https://api.telegram.org/bot${BOT_TOKEN}"

          # Read previous state (safe)
          MESSAGE_ID=""
          FILE_ID=""
          if [ -f "$STATE_FILE" ]; then
            MESSAGE_ID=$(jq -r '.message_id // empty' "$STATE_FILE" 2>/dev/null || echo "")
            FILE_ID=$(jq -r '.file_id // empty' "$STATE_FILE" 2>/dev/null || echo "")
          fi

          # Ensure variables are defined (avoid unbound var with set -u)
          : "${FILE_ID:=}"
          # VIDEO_PATH comes from env and is allowed to start with ':'
          : "${VIDEO_PATH:=${VIDEO_PATH:-}}"
          : "${EXTERNAL_VIDEO_URL:=${EXTERNAL_VIDEO_URL:-}}"

          echo "MESSAGE_ID='${MESSAGE_ID:-<empty>}'"
          if [ -n "$FILE_ID" ]; then
            echo "FILE_ID='${FILE_ID:0:8}... (redacted)'"
          else
            echo "FILE_ID='<empty>'"
          fi
          echo "VIDEO_PATH='$VIDEO_PATH'"
          echo "EXTERNAL_VIDEO_URL='${EXTERNAL_VIDEO_URL:+<set>}'"

          # delete previous message (best-effort)
          if [ -n "$MESSAGE_ID" ]; then
            echo "Attempting to delete previous message $MESSAGE_ID..."
            curl -s -X POST "${API}/deleteMessage" -d chat_id="${CHAT_ID}" -d message_id="${MESSAGE_ID}" || true
          fi

          # If no file_id and EXTERNAL_VIDEO_URL provided, download it
          if [ -z "$FILE_ID" ] && [ -n "$EXTERNAL_VIDEO_URL" ]; then
            echo "Downloading external video from $EXTERNAL_VIDEO_URL..."
            curl -sSfL "$EXTERNAL_VIDEO_URL" -o /tmp/video.mp4
            FOUND_PATH="/tmp/video.mp4"
          else
            FOUND_PATH=""
            # Try exact VIDEO_PATH, then ./VIDEO_PATH â€” this covers filenames starting with ':'
            for candidate in "$VIDEO_PATH" "./$VIDEO_PATH"; do
              if [ -f "$candidate" ]; then
                FOUND_PATH="$candidate"
                break
              fi
            done
          fi

          # If we still don't have a file and we don't have a FILE_ID, error
          if [ -z "$FILE_ID" ] && [ -z "$FOUND_PATH" ]; then
            echo "ERROR: No file_id and video file not found at '$VIDEO_PATH' or './$VIDEO_PATH'." >&2
            echo "Working dir listing (repo root):"
            ls -la || true
            exit 1
          fi

          # perform send with HTTP code attached to output
          if [ -n "$FILE_ID" ]; then
            SEND_RAW=$(curl -s -w "\n__HTTP_CODE__:%{http_code}" -X POST "${API}/sendVideo" \
              -d chat_id="${CHAT_ID}" -d video="${FILE_ID}" -d disable_notification=true) || true
          else
            # use the found path for upload
            SEND_RAW=$(curl -s -w "\n__HTTP_CODE__:%{http_code}" -X POST "${API}/sendVideo" \
              -F chat_id="${CHAT_ID}" -F "video=@${FOUND_PATH}" -F disable_notification=true) || true
          fi

          HTTP_CODE=$(printf '%s' "$SEND_RAW" | tail -n1 | sed -E 's/__HTTP_CODE__:(.*)/\1/')
          SEND_JSON=$(printf '%s_
